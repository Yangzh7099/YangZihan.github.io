[{"title":"如何使用stream优化代码","date":"2021-10-31T09:30:19.000Z","path":"2021/10/31/stream/","text":"如何使用jdk1.8特性优化代码(一)通过stream api优化代码什么是steamSteam概述Stream是 Java 8新增加的类，用来补充集合类。Stream代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。Java Stream提供了提供了串行和并行两种类型的流，保持一致的接口，提供函数式编程方式，以管道方式提供中间操作和最终执行操作，为Java语言的集合提供了现代语言提供的类似的高阶函数操作。 Steam的并行流并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。串行流则相反，并行流的底层其实就是ForkJoin框架的一个实现。 使用ForkJoin时，任务的量一定要大，否则太小，由于任务拆分也会消耗时间，它执行的效率不一定比for循环高。 函数式编程我们最常用的面向对象编程（Java）属于命令式编程（Imperative Programming）这种编程范式。常见的编程范式还有逻辑式编程（Logic Programming），函数式编程（Functional Programming）。 什么是函数式编程？简单的回答：一切都是数学函数。函数式编程语言里也可以有对象，但通常这些对象都是恒定不变的 —— 要么是函数参数，要什么是函数返回值。函数式编程语言里没有 for/next 循环，因为这些逻辑意味着有状态的改变。相替代的是，这种循环逻辑在函数式编程语言里是通过递归、把函数当成参数传递的方式实现的。 Stream怎么产生无限的流数据？1.使用 iterate 方法 获取前30个Fibonacci数字，如果去掉limit则会无限打印 1234567891011121314151617181920212223/** * @author yangzihan */public class InfiniteStream &#123; public static void main(String[] args) &#123; IntStream.iterate(1, k -&gt; Math.addExact(k, 1)).limit(30) .forEach(x -&gt; System.out.println(getN(x))); &#125; private static int getN(int k) &#123; if (k == 0) &#123; return 0; &#125; if (k == 1) &#123; return 1; &#125; if (k == 2) &#123; return 2; &#125; return getN(k - 1) + getN(k - 2); &#125;&#125; 2.实现IntSupplier 获取前10个质数，如果去掉limit则会无限打印 123456789101112131415161718// 埃氏筛选法找质数IntSupplier primeSupplier = new IntSupplier() &#123; private int currPrime = 2; private List&lt;Integer&gt; primeList = new ArrayList&lt;&gt;(); @Override public int getAsInt() &#123; if(!primeList.isEmpty())&#123; boolean notFind = true; while(notFind)&#123; currPrime++; notFind = primeList.stream().anyMatch(n -&gt; currPrime%n==0); &#125; &#125; primeList.add(currPrime); return currPrime; &#125;&#125;;IntStream.generate(primeSupplier).limit(10).forEach(System.out::println); Stream使用stream的使用分为3步，分别问创建，中间操作，终止操作 创建从一个数据源，如集合、数组中获取流 1234567891011121314151617181920212223242526272829303132// a.使用集合创建流 Stream&lt;User&gt; userStream = userList.stream(); //创建串行流 Stream&lt;User&gt; userStreamPal = userList.parallelStream(); //创建并行流// b.指定数据创建流 Stream&lt;User&gt; userStream = Stream.of(user1, user2); //创建串行流// c.使用数组创建流// 1.使用Stream.of User[] users = getUserArray(); Stream&lt;User&gt; userStream = Stream.of(users);// 2.使用Stream.of Stream&lt;String&gt; stringStream = Arrays.stream(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;);// 3.对于int,double,long三种基础类型有单独的stream封装类可以进行数组转换 IntStream intStream = Arrays.stream(new int[0]); LongStream longStream = Arrays.stream(new long[0]); DoubleStream doubleStream = Arrays.stream(new double[0]);// 4.对于char,byte,short,float等基础数据类型数组转换可以用这种方式, char,byte,short转为IntStream,float转为DoubleStream char c[] = &quot;&quot;.toCharArray(); IntStream intStream = IntStream.range(0, c.length).map(i -&gt; c[i]); float[] floatArray = new float[0]; DoubleStream ds = IntStream.range(0, floatArray.length).mapToDouble(i -&gt; floatArray[i]);// d.字符串分割创建流 String sentence = &quot;ma zhi chu is a Java wechat official account.&quot;; Stream&lt;String&gt; wordStream = Pattern.compile(&quot;\\\\W&quot;).splitAsStream(sentence); 中间操作1.筛选 根据条件过滤 1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); 根据条数过滤，获取前maxSize条数据 1Stream&lt;T&gt; limit(long maxSize); 跳过n个元素 1Stream&lt;T&gt; skip(long n); 去重，根据hashCode()和equals()去除重复元素 1Stream&lt;T&gt; distinct(); 2.映射 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 将一个流的所有元素，全部映射为另一个元素 map将一个元素映射到另一个元素 1&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 将一个流的所有元素，全部映射为另一个流 flatMap将一个元素映射到另一个流 123456Arrays.asList(&quot;aa bb cc&quot;, &quot;tt qq aa&quot;).stream().map(x -&gt; Arrays.stream(x.split(&quot; &quot;))).forEach(x -&gt; System.out.print(x + &quot; &quot;));System.out.println();Arrays.asList(&quot;aa bb cc&quot;, &quot;tt qq aa&quot;).stream().flatMap(x -&gt; Arrays.stream(x.split(&quot; &quot;))).forEach(x -&gt; System.out.print(x + &quot; &quot;));java.util.stream.ReferencePipeline$Head@69663380 java.util.stream.ReferencePipeline$Head@5b37e0d2 aa bb cc tt qq aa map映射了一次，直接映射为流 flatMap映射了两次，先把数据映射为流，再把流里面的数据扁平化处理 3.排序 1Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); 终止操作1.匹配 123boolean anyMatch(Predicate&lt;? super T&gt; predicate); boolean noneMatch(Predicate&lt;? super T&gt; predicate); boolean allMatch(Predicate&lt;? super T&gt; predicate); 2.查找 12Optional&lt;T&gt; findAny();Optional&lt;T&gt; findFirst(); 3.统计 123long count(); Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); 4.计算 12345Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); &lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); 5.收集 1234567891011121314151617181920212223242526 &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); // 参数可以为： Collectors.toList(); Collectors.toSet(); // t-&gt;t 可以替换为 Function.identity() // 需要注意的是，使用该方法，生成map时，如果存在重复的key，会报错 getUsers().stream().collect(Collectors.toMap(user -&gt; user.getId(), t-&gt;t)); public static &lt;T, K, U&gt;Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper) &#123; return toMap(keyMapper, valueMapper, throwingMerger(), HashMap::new); &#125; // 查看源码发现，它在传入了mergeFunction这个参数中传入了throwingMerger() // mergeFunction表示如果出现重复的key，如何进行处理 // throwingMerger()表示如果没有处理重复的key，则会直接抛异常 public static &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper, BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier) // 所以我们用上面的方法来构造toMap，减少不必要的问题出现 getUsers().stream().collect(Collectors.toMap(user -&gt; user.getId(), Function.identity(), (oldValue, newValue) -&gt; newValue, HashMap::new));","tags":[{"name":"java基础","slug":"java基础","permalink":"https://yangzihan.github.io.git/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java 编码","date":"2021-10-28T14:21:51.000Z","path":"2021/10/28/code/","text":"为什么要编码​ 由于人类的语言有太多，因而表示这些语言的符号太多，无法用计算机中一个基本的存储单元—— byte 来表示，因而必须要经过拆分或一些翻译工作，才能让计算机能理解。 编码的原因可以总结为： 计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个 人类要表示的符号太多，无法用一个字节来完全表示 要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码 如何“翻译”​ 计算中提拱了多种翻译方式，常见的有 ASCII、ISO-8859-1、GBK、UTF-8 等。它们都可以被看作为字典，它们规定了转化的规则，按照这个规则就可以让计算机正确的表示我们的字符。 常用的编码ASCII 码ascii码，全称为 American Standard Code for Information Interconnection，中文翻译过来就是：美国信息交换标准代码 一个ascii码只有一个字节，所以ascii码总共有128 个，用一个字节的低 7 位表示，031 是控制字符如换行回车删除等；32126 是打印字符，可以通过键盘输入并且能够显示出来 数字的ascii码是48-57 大写英文字母的ascii码是65-90 小写英文字母的ascii码是97-122 利用ascii码可以很轻松的统计数字，大小写英文字母的数据个数 123456789101112131415161718192021222324252627import java.util.stream.Stream;public class Count &#123; public static void main(String[] args) &#123; String t = &quot;12e2eqwrt32trQWE!@E@!r12235#$@T$#&amp;$%U*%^UJH$T#@R23e&quot;; countNumber(t); countLowercaseLetters(t); countUppercaseLetters(t); &#125; public static void countNumber(String str) &#123; Stream&lt;Character&gt; s = String.valueOf(str).chars().mapToObj(a -&gt; (char) a); System.out.println(&quot;数字有:&quot; + s.filter(x -&gt; x &gt;= 48 &amp;&amp; x &lt;= 67).count() + &quot;个&quot;); &#125; public static void countLowercaseLetters(String str) &#123; Stream&lt;Character&gt; s = String.valueOf(str).chars().mapToObj(a -&gt; (char) a); System.out.println(&quot;大写字母有:&quot; + s.filter(x -&gt; x &gt;= 65 &amp;&amp; x &lt;= 90).count() + &quot;个&quot;); &#125; public static void countUppercaseLetters(String str) &#123; Stream&lt;Character&gt; s = String.valueOf(str).chars().mapToObj(a -&gt; (char) a); System.out.println(&quot;小写字母有:&quot; + s.filter(x -&gt; x &gt;= 97 &amp;&amp; x &lt;= 122).count() + &quot;个&quot;); &#125;&#125; ISO-8859-1编码ISO-8859-1 是大多数浏览器默认的字符集。 ISO-8859-1 的较低部分（从 1 到 127 之间的代码）是最初的 ASCII 字符集（0-9 的数字，大写和小写英文字母表，以及一些特殊字符）。 ISO-8859-1 的较高部分（从 160 到 255 之间的代码）包含了一些西欧国家使用的字符和一些被广泛使用的特殊字符，它们全都有实体名称。 Latin1是ISO-8859-1的别名 属于单字节编码，最多能表示的字符范围是0-255 Unicode编码由于ASCII编码方式包含的字符太少,基本只对英文字符进行了编码. 为了方便交流,防止乱码,Unicode编码方式应运而生. Unicode编码被称为万国码,单一码,统一码.它是为每种语言的每个字符都设定了统一的,唯一的二进制编码,以满足跨语言,跨平台进行文本交换和处理的需求,是计算机科学领域的一项业界标准.对于 Unicode 有一些误解，它仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定。它的想法很简单，就是为每个字符规定一个用来表示该字符的数字，仅此而已。 Unicode对英文进行编码,相对于ASCII编码来说,会更占用空间.Unicode使用两个字节存储,而英文存储本身只需要占用一个字节,用Unicode编码,就会在多出的一个字节上全部置零.这就造成了空间浪费.于是就有了UTF-8编码 Java中一个字符用Unicode编码为什么不是两字节在java程序中，使用Unicode计算字节数，会发现Unicode占用4个字节，与之前的预期不符 123456789public static void main(String[] args) &#123; String a = &quot;啊&quot;; // 一个中文字符 try &#123; System.out.println(&quot;unicode&quot; + &quot;编码字符所占字节数:&quot; + a.getBytes(&quot;unicode&quot;).length);//a.getBytes(&quot;utf-8&quot;).length &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;&#125; 二进制的高低位一个16位的二级制数符占两个字节的存储空间，即高位字节和低位字节。如果你是在纸上书写一个16位的数，你总是会把高位字节写在前面，而把低位字节写在后面。然而，当这个数被存储到计算机中时，并没有固定的存储顺序。 如果我们用M和L分别表示高位字节和低位字节，那么可以有两种方式把这两个字节存储到计算机存中，即M在前L在后或者L在前M在后。 把M存储在前的顺序被称为“正向(forward)”或“高位优先(big—endian)”顺序；把L存储在前的顺序被称为“逆向(reverse)”或“低位优先(little—endian)”顺序。 big—endian这个术语的含义是数的“高位(big end)”存储在前。 大多数计算机按正向顺序存储一个数，Intel CPU按逆向顺序存储一个数，因此，如果试图将基于Intel CPU的计算机连到其它类型的计算机上，就可能会引起混乱。另外，当字节流在网络上传输时，如果你从高位到低位的顺序发送，接受者却以低位到高位的顺序结束，也会发生混乱。 那么，怎样明确的通过一些方式来表明字节的高低位顺序呢？ BOMBOM（Byte Order Mark），字节顺序标记。 unicode编码规范中编码中有一个叫做 “Zero Width No-Break Space” ，中文译名作“零宽无间断间隔”的字符，它的编码用十六进制表示是FEFF。而 FEFF 在 unicode 中是不存在的字符，所以不应该出现在实际内容中。unicode 规范建议我们在传输字节流前，先传输这个FEFF。这样如果接收者收到 FEFF，就表明这个字节流是Big-Endian(高位在前) 的；如果收到FFFE，就表明这个字节流是 Little- Endian(低位在前)的。因此字符 “Zero Width No-Break Space” （“零宽无间断间隔”）又被称作 BOM。 说白了就是用一个专门的unicode字符来加在实际内容的前面，来告诉使用者我这个内容里的字节顺序是高位在前还是低位在前的。 如此一来，上面程序的结果也就能解释的通了。 基于unicode的编码总会比实际内容多出两个字节，就是那个BOM，它也是一个unicode字符，所有也需两字节。 而utf-8编码有自己特殊的特征，它完全可以根据自己的编码方式避免这个高低位顺序的问题，所以不需要BOM。 UTF-8编码它是Unicode的实现方式之一,是一种可变字节的编码方式,用1-4个字节来表示一个字符.对英文就使用1个字节来表示.对汉字就使用3个字节来表示。 UTF-8 是一个非常惊艳的编码方式，漂亮的实现了对 ASCII 码的向后兼容，以保证 Unicode 可以被大众接受。 编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 编码规则如下： 根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。 “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB7 0x89。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节。 GBK编码GBK，全称为Chinese Internal Code Specification，即汉字内码扩展规范。它主要是扩展了GB2312。 这就是汉字的国标码，专门用来表示汉字，是双字节编码 URL编码首先要明确一点的是，URL编码和之前的编码不是一个概念。 URL编码不是一个编码字符集，它是一个为了传送数据而产生的编码方式 什么是编码字符集？能够实现二进制数据 &lt;—-&gt; 具体字符 的互相转换 但有人可能会疑惑，明明URL编码也能实现同样的功能啊。所以我们可以通过源码来一探究竟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public static String encode(String s, String enc) throws UnsupportedEncodingException &#123; boolean needToChange = false; StringBuffer out = new StringBuffer(s.length()); Charset charset; CharArrayWriter charArrayWriter = new CharArrayWriter(); // 字符集不能为null if (enc == null) throw new NullPointerException(&quot;charsetName&quot;); try &#123; charset = Charset.forName(enc); &#125; catch (IllegalCharsetNameException e) &#123; throw new UnsupportedEncodingException(enc); &#125; catch (UnsupportedCharsetException e) &#123; throw new UnsupportedEncodingException(enc); &#125; for (int i = 0; i &lt; s.length();) &#123; // 如果s[i]是ascii码，则不需要进行编码 int c = (int) s.charAt(i); if (dontNeedEncoding.get(c)) &#123; if (c == &#x27; &#x27;) &#123; c = &#x27;+&#x27;; needToChange = true; &#125; //System.out.println(&quot;Storing: &quot; + c); out.append((char)c); i++; &#125; else &#123; // 如果s[i]不是ascii码，则需要找到下一个连续的非ascii码字符串 // 例如 // &quot;ab你好c我的天空&quot; // 前两个字母ab直接写入out里面，将你好这两个词语，写入charArrayWriter中 do &#123; charArrayWriter.write(c); // 处理代理块 // 其中0xD800 至 0xDBFF（高代理high surrogate） 和 0xDC00 至 0xDFFF（低代理low surrogate）被称为surrogate blocks（代理块） // 代理块是为了表示增补字符 增补字符是在 [#x10000-#x10FFFF] 范围之间的字符 if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDBFF) &#123; if ( (i+1) &lt; s.length()) &#123; int d = (int) s.charAt(i+1); if (d &gt;= 0xDC00 &amp;&amp; d &lt;= 0xDFFF) &#123; charArrayWriter.write(d); i++; &#125; &#125; &#125; i++; &#125; while (i &lt; s.length() &amp;&amp; !dontNeedEncoding.get((c = (int) s.charAt(i)))); charArrayWriter.flush(); String str = new String(charArrayWriter.toCharArray()); // 根据编码，转化为字节数组 byte[] ba = str.getBytes(charset); for (int j = 0; j &lt; ba.length; j++) &#123; out.append(&#x27;%&#x27;); // 获取高位字母 char ch = Character.forDigit((ba[j] &gt;&gt; 4) &amp; 0xF, 16); // converting to use uppercase letter as part of // the hex value if ch is a letter. // 如果为字母，则如果转化为大写字母 if (Character.isLetter(ch)) &#123; ch -= caseDiff; &#125; out.append(ch); // 获取低位字母 ch = Character.forDigit(ba[j] &amp; 0xF, 16); if (Character.isLetter(ch)) &#123; ch -= caseDiff; &#125; // 如果为字符，则如果转化为大写字母 out.append(ch); &#125; charArrayWriter.reset(); needToChange = true; &#125; &#125; return (needToChange? out.toString() : s);&#125; 简单解释一下UrlEncode流程 使用utf-8 编码”abc你好de” a,b,c都是不需要进行编码的字符，所以直接写入out，现在out为abc 获取”你好”字符串 将”你好”用utf-8进行解码，获取到byte数组 将高四位和低四位的byte分别转化为16进制，并将字母转化为大写字母，在前面加上%，写入out中，现在out为abc%E4%BD%A0%E5%A5%BD 处理剩下的de，发现de都是不需要进行编码的字符，所以直接写入out，现在out为abc%E4%BD%A0%E5%A5%BDde 使用gbk编码获取”abc你好de”的UrlEncode结果则是 abc%C4%E3%BA%C3de 各编码中文英文字节数验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.UnsupportedEncodingException;public class Code &#123; public static void main(String[] args) &#123; String[] charsetNames = &#123;&quot;utf-8&quot;, &quot;Unicode&quot;, &quot;GBK&quot;, &quot;ISO8859-1&quot;, &quot;ASCII&quot;&#125;; for (int i = 0; i &lt; charsetNames.length; i++) &#123; printByteLength(charsetNames[i]); printByteLength2(charsetNames[i]); printByteLength3(charsetNames[i]); &#125; &#125; public static void printByteLength(String charsetName) &#123; String a = &quot;a&quot;; // 一个英文字符 String b = &quot;啊&quot;; // 一个中文字符 try &#123; System.out.println(&quot;1个&quot; + charsetName + &quot;编码英文字符所占字节数:&quot; + a.getBytes(charsetName).length);//a.getBytes(&quot;utf-8&quot;).length System.out.println(&quot;1个&quot; + charsetName + &quot;编码中文字符所占字节数:&quot; + b.getBytes(charsetName).length); System.out.println(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(&quot;非法编码格式！&quot;); &#125; &#125; public static void printByteLength2(String charsetName) &#123; String a = &quot;aa&quot;; // 一个英文字符 String b = &quot;啊啊&quot;; // 一个中文字符 try &#123; System.out.println(&quot;2个&quot; + charsetName + &quot;编码英文字符所占字节数:&quot; + a.getBytes(charsetName).length);//a.getBytes(&quot;utf-8&quot;).length System.out.println(&quot;2个&quot; + charsetName + &quot;编码中文字符所占字节数:&quot; + b.getBytes(charsetName).length); System.out.println(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(&quot;非法编码格式！&quot;); &#125; &#125; public static void printByteLength3(String charsetName) &#123; String a = &quot;aaa&quot;; // 一个英文字符 String b = &quot;啊啊啊&quot;; // 一个中文字符 try &#123; System.out.println(&quot;3个&quot; + charsetName + &quot;编码英文字符所占字节数:&quot; + a.getBytes(charsetName).length);//a.getBytes(&quot;utf-8&quot;).length System.out.println(&quot;3个&quot; + charsetName + &quot;编码中文字符所占字节数:&quot; + b.getBytes(charsetName).length); System.out.println(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(&quot;非法编码格式！&quot;); &#125; &#125;&#125; 显示结果： 1个utf-8编码英文字符所占字节数:11个utf-8编码中文字符所占字节数:3 2个utf-8编码英文字符所占字节数:22个utf-8编码中文字符所占字节数:6 3个utf-8编码英文字符所占字节数:33个utf-8编码中文字符所占字节数:9 1个Unicode编码英文字符所占字节数:41个Unicode编码中文字符所占字节数:4 2个Unicode编码英文字符所占字节数:62个Unicode编码中文字符所占字节数:6 3个Unicode编码英文字符所占字节数:83个Unicode编码中文字符所占字节数:8 1个GBK编码英文字符所占字节数:11个GBK编码中文字符所占字节数:2 2个GBK编码英文字符所占字节数:22个GBK编码中文字符所占字节数:4 3个GBK编码英文字符所占字节数:33个GBK编码中文字符所占字节数:6 1个ISO8859-1编码英文字符所占字节数:11个ISO8859-1编码中文字符所占字节数:1 2个ISO8859-1编码英文字符所占字节数:22个ISO8859-1编码中文字符所占字节数:2 3个ISO8859-1编码英文字符所占字节数:33个ISO8859-1编码中文字符所占字节数:3 1个ASCII编码英文字符所占字节数:11个ASCII编码中文字符所占字节数:1 2个ASCII编码英文字符所占字节数:22个ASCII编码中文字符所占字节数:2 3个ASCII编码英文字符所占字节数:33个ASCII编码中文字符所占字节数:3 乱码乱码问题的产生最根本的原因就是使用错误的字符集解码字节流或者将给定的字符串 用错误的字符集编码成字节流造成的，例如”中文”两个汉字，如果用ISO8859-1字符集将其编码为字节流，因为这个字符集不支持中文，所以就会出 错，输出结果为3f3f，其意义就是??。再例如”中文”二字的GBK的字节流为d6 d0 ce c4，可是我们要是用不兼容的字符集去解码，例如用ISO8859-1或者UTF-8，这随后产生的字符串就是乱码，或者是其他的某个字符。 一般来说给定的字符串 用错误的字符集编码成字节流，是工作中更容易出现乱码的原因。 例如，一个文件是gbk编码，我们使用utf-8的编码字符集进行读取，就会出现乱码 如何解决乱码1.很多的乱码问题，很可能是没有对相应的编码字符集进行配置，找到原因，配置就没问题 2.如果是与其他人对接，则需要确认对方的编码格式是否与你的编码格式一致，然后才能解决 3.如果是在调用系统相关功能出现乱码，或者确定不了对应编码格式，则可以根据乱码特征进行编码的猜测","tags":[{"name":"java基础","slug":"java基础","permalink":"https://yangzihan.github.io.git/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"jvm 原理及垃圾回收","date":"2021-10-27T15:25:45.000Z","path":"2021/10/27/jvm/","text":"Java运行时数据区域 在jdk1.8以前，永久代中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中 程序计数器","tags":[{"name":"java基础","slug":"java基础","permalink":"https://yangzihan.github.io.git/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java 基础类型","date":"2021-10-23T16:00:00.000Z","path":"2021/10/24/foundation-type/","text":"一.java基础类型 java中有8种基本类型，分为4类，分别为： 整型：包括 byte 、 short、 int 、 long 泛型：float、double 字符型：char 布尔型：boolean 取值范围char 数字范围为：0-65535 整型的取值范围均为 -2^n 到 2^n-1 (n为bit数) 不能直接赋值超过取值范围的数值，编译不通过 数据的溢出：当整数的数据大小超出了可以表示的范围，而程序中又没有做数值范围的检查时， 这个整型变量所输出的值将发生紊乱，且不是预期的运行结果。 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; byte a = 127; System.out.println(plus(a)); byte b = -128; System.out.println(reduce(b)); &#125; public static byte plus(byte b) &#123; b += 1; return b; &#125; public static byte reduce(byte b) &#123; b -= 1; return b; &#125;&#125; 当最大值加上 1 时，结果反而变成表示范围中最小的值 当最小值减去 1 时，结果反而变成表示范围中最大的值 二.包装类什么是包装类java中的数据类型int，double等不是对象，无法通过向上转型获取到Object提供的方法，而像String却可以，只因为String是一个对象而不是一个类型。基本数据类型由于这样的特性，导致无法参与转型，泛型，反射等过程。为了弥补这个缺陷，java提供了包装类。 为什么要有包装类1.效率问题 ​ Java语言中，new一个对象存储在堆里，我们通过栈中的引用来使用这些对象；但是对于经常用到的一系列类型如int，如果我们用new将其存储在堆里就不是很有效。对于这些类型不是用new关键字来创建，而是直接将变量的值存储在栈中，因此更加高效。 和这个问题类似的有 为什么 Java 需要一个单独的字符串常量池来存储字符串？为什么字符串不像其它对象那样存储在堆内存中？ 通常，在一个 Java 业务应用程序会创建并处理成千上万个字符串对象（实际开发中几乎没有不使用 String 的程序），这些字符串对象中有许多具有相同的值或者是中间操作字符而非最终结果。如果我们将所有这些字符串对象存储在堆内存中，仅仅是存储这些字符串对象就需要占用大量的堆内存。当回收不再使用的字符串对象时也会导致垃圾收集器频繁地运行，这将大大降低应用程序的性能。 为了避免 JVM 首先创建大量的字符串对象，然后再进行垃圾回收。 JVM 将所有字符串字面量存储在称为字符串常量池的单独内存区域中，并重用该高速缓存池中的对象。 当我们创建字符串字面量时，JVM 就会首先查看 SCP 中是否已经存在该字符串字面量，如果存在，则新的引用变量指向 SCP 中的同一个字符串字面量，这个过程称为 String Interning。 按照这个逻辑，再想一想，为什么包装类会存在缓存数据？是不是和上面的原因很类似？ 2.设计问题 ​ Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型 拆箱装箱拆箱，即，把基包装类型转换为基本类型 1234int i=new Integer(0);等同于Integer ii = new Integer(0);int i = ii.intValue(); 装箱，即，基本类型转换为对应的包装类型 123Integer i = 0;等同于Integer i=new Integer(0); 需要注意的是 Double d=2; 这种语句是会编译不通过的 即便Double d=new Double(2);是没有问题的 原因：java: 不兼容的类型: int无法转换为java.lang.Double 装箱只适用于同种类型的基础数据类型 1short a=new Byte((byte) 1); 但是拆箱却满足向上转型的规则，上面这一句能编译成功的 1short a=new Integer(1); 而这一句是编译不成功的 包装类缓存Byte、Short、Integer、Long、Character的定义中都有一个缓存机制，-128~127对应的对象会缓存到缓存中，调用valueOf()方法时，会先判断数据是否在这个范围内，如果在范围内，返回缓存对象，如果超出范围，新建一个对象返回 1234567891011121314Integer a1 = new Integer(127);Integer a2 = new Integer(127);System.out.println(a1 == a2);// falseInteger a3 = 127;Integer a4 = 127;System.out.println(a3 == a4);// tureInteger a5 = 128;Integer a6 = 128;System.out.println(a5 == a6);// false 向上转型取值范围小的类型可自动转换为取值范围大的数据类型；(和数据所占用的字节数大小没有关系) 例如 long的字节数是8，float的字节数是4，但是float是不能转化为long的，因为float的取值范围比long更大 byte,short,char → int → long → float → double byte，short，char之间不会相互转换，他们在计算时首先会转换为int类型。 boolean 类型是不可以转换为其他基本数据类型。","tags":[{"name":"java基础","slug":"java基础","permalink":"https://yangzihan.github.io.git/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"你好，这里是杨子寒的个人博客","date":"2021-10-19T16:00:00.000Z","path":"2021/10/20/yangzihan/","text":"为什么创建博客​ 可能是因为无聊，可能是因为一时兴起，可能是因为想积累技术，可能是因为程序员都应该创建一个博客，也可能是因为想要记录点什么。 ​ 人始终要不断学习新的事物，新的知识，在这个互联网时代，信息如此发达，以致于获取到知识的成本非常低廉。以前的人们学习的途径可能是自己阅读书籍，可能是通过老师传授知识，大家总是会格外珍惜学到的知识，小心翼翼的爱护自己的笔记和书籍。但现在，触手可得的知识仿佛变得廉价，人们不再会去专门记录自己所学的东西，因为即便忘了，只有上网一搜，答案就出来了。我们变得逐渐只需要去记住索引，不用去记住内容。我们将知识抛弃在浩瀚的互联网中，却不曾知晓，我们也早已被抛弃。 ​ 所以，我想要记录点什么，就像小时候课堂认真的笔记一样，或是记录以前感兴趣的书籍一样。 博客的内容​ 目前的博客还是以技术记录为主，对于一些感兴趣的事物也会进行记录 ​ 编程语言：java，python ​ 中间件：rocketMq，kafka，rabbitMq，redis，elasticsearch，logstash，hadoop，hbase，zookeeper，mysql ​ 框架：springCloud，springCloudAlibaba，springBoot，dubbo ​ 协议：http，https，ftp，rpc ​ 项目搭建：docker，k8s 写博客的频率​ 一周一次 致自己​ 希望自己能够坚持下去","tags":[{"name":"生活","slug":"生活","permalink":"https://yangzihan.github.io.git/tags/%E7%94%9F%E6%B4%BB/"}]}]